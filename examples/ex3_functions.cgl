/* Example #3 - Functions
 * This example showcases functions in cgull, particularly
 * their syntax for passing variables, recursion, returns,
 * and multiple return values.
 */

struct Node {
  string value;
  Node* next;
}

fn printNodes(Node* head) -> void {
  if (!head) {
    return;
  }
  println(head->value);
  // recursive call
  printNodes(head->next);
}

// void return can be omitted
fn deallocateList(Node* head) {
  Node* curr = head;
  for (curr) {
    Node* next = curr->next;
    deallocate curr; // deallocate memory
    curr = next;
  }
}

// Node*, Node* is also valid for multiple return values
fn getNeighbors(Node* head, string c) -> (Node*, Node*) {
  Node* prev = nullptr;
  Node* curr = head;
  Node* next = nullptr;
  // while loop, similar to Golang's for loop
  for (curr != nullptr) {
    if (curr->value == c) {
      next = curr->next;
      break;
    }
    prev = curr;
    curr = curr->next;
  }
  return (prev, next);
}

fn main() -> int {
  // dynamic memory allocation
  Node* head = allocate Node("A", nullptr);
  head->next = allocate Node("B", nullptr);
  head->next->next = allocate Node("C", nullptr);
  head->next->next->next = nullptr;

  printNodes(head);
  Node* prev, Node* next = getNeighbors(head, "B");

  println("Previous of B: " + (if (prev) prev->value else " "));
  println("Next of B: " + (if (next) next->value else " "));

  deallocateList(head);

  return 0;
}

/* expected output:
 * A
 * B
 * C
 * Previous: A
 * Next: C
 */
