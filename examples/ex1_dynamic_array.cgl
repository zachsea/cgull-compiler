/* Example #1 - Dynamic Array
 * Below is what a very primitive implementation of a dynamic array
 * would look like in cgull. It is not a perfect implementation.
 * This sample covers a large set of features not limited to:
 * Functions, structs, access blocks, memory management
 * (allocation), implicit conversions, fixed-sized arrays, and more.
 *
 * See other examples for more granular examples of the features.
 */

struct IntVector {
  // members may be prefixed with access modifiers public (redundant) or private
  // or they can be placed in a block with the access modifier
  private {
    int size = 0;
    int capacity = 0;
    int[] data;

    fn resize(int new_capacity) {
      int[] new_data = allocate int[new_capacity];
      for (int i = 0; i < size; i++) {
        new_data[i] = data[i];
      }
      data = new_data;
      capacity = new_capacity;
    }
  }

  fn getSize() -> int {
    return size;
  }

  fn push_back(int v) {
    if (size == capacity) {
      // ternary
      resize(if (capacity > 0) capacity * 2 else 1);
    }
    data[size++] = v;
  }


  fn at(int index) -> int {
    return data[index];
  }
  // corresponds to object[index] = value
  fn set(int index, int value) {
    data[index] = value;
  }

  // defaults to memory address
  fn $toString() -> string {
    string result = "[";
    for (int i = 0; i < size; i++) {
      result = result + data[i];
      if (i < size - 1) {
        result = result + ", ";
      }
    }
    result = result + "]";
    return result;
  }
}

fn main() {
  IntVector vec = IntVector();
  IntVector vec2 = IntVector();
  for (int i = 0; i < 10; i++) {
    vec.push_back(i);
    vec2.push_back(i * 2);
  }
  // $toString will be called implicitly since a string is expected
  println(vec);
  println(vec2);
}

/* expected output:
 * [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 * [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
 * Index out of bounds
 */
